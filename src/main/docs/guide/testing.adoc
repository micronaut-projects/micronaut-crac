When you create a Micronaut Framework application (either via https://launch.micronaut.io or the command line application), it creates a https://docs.micronaut.io/latest/api/io/micronaut/context/annotation/ContextConfigurer.html[ContextConfigurer] with enables https://docs.micronaut.io/latest/guide/index.html#eagerInit[eager singleton initialization].

As tests annotated with `@MicronautTest` are implicitly in the `Singleton` scope, this can cause problems injecting some beans (for example an `HttpClient`) into your test class.

To avoid this, you can either disable eager singleton initialization for your tests, or you will need to manually get an instance of the bean you would normally inject.  As an example, to get an `HttpClient` you could do:

snippet::io.micronaut.crac.EagerHttpClientCreationTest[tags=test,indent=0,title=Lazily get an HttpClient in a test]

<1> Inject the `EmbeddedServer` as normal
<2> Lazily create a `HttpClient` when it is first called
<3> Get the `HttpClient` and make the request

With CRaC, you run your application to a point, and then "checkpoint" it. This calls the app to close all its sockets and file handles, and then dumps the memory to disk. When it restarts from this snapshot, it calls the app again to say it's been restored, and one can re-open files and network connections.

The simulator allows you to synthesise these 2 calls (before checkpoint and after restore), so that under a test, you can check your service that it works again after it was closed and recreated.

snippet::io.micronaut.crac.CheckpointSimulatorTest[tags=test,indent=0,title=Using CheckpointSimulator in a test]

<1> Obtain the `CheckpointSimulator` from the running environment
<2> Emulate the checkpoint and assert the server is no longer running
<3> Emulate the restore and assert the server restarted
